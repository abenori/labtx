\documentclass[a4paper]{ltjsarticle}
\usepackage[hiragino-pron]{luatexja-preset}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{url}
\usepackage{listings}
\usepackage[rgb,x11names]{xcolor}
\usepackage{xparse}
\usepackage{enumitem}
\lstdefinestyle{Lua}{%
  language=[5.2]Lua,
  basicstyle=\ttfamily,
  columns=spaceflexible,
  keywordstyle=\bfseries\color{Blue4},% language keywords
  keywordstyle=[2]\bfseries\color{RoyalBlue3},% std. library identifiers
  keywordstyle=[3]\bfseries\color{Purple3},% labels
  stringstyle=\bfseries\color{Coral4},% strings
  commentstyle=\gtfamily\color{Green4},% comments
  lineskip=-0.5\zw,
}
\lstset{style=Lua,tabsize=2,showspaces=false}
\DeclareRobustCommand{\LBibTeX}{L\BibTeX}
\newcommand{\luafunc}[1]{\texttt{#1}}
%\NewDocumentCommand{\luafunc}{v}{\texttt{#1}}
\newcommand*{\luatable}[1]{\texttt{#1}}
\NewDocumentCommand{\luastring}{v}{``\texttt{#1}''}
%\NewDocumentCommand{\luavar}{v}{\texttt{#1}}
\newcommand*{\luavar}[1]{\texttt{#1}}
\NewDocumentCommand{\texcs}{v}{\texttt{#1}}
\renewcommand{\theenumi}{\inhibitglue（\arabic{enumi}）\inhibitglue}
\renewcommand{\labelenumi}{\theenumi}
\title{\LBibTeX}
\date{}
\begin{document}
\maketitle
Luaによる\BibTeX の実装です．

\section{使い方}
TeX LiveまたはW32TeXをインストールしておいてください．
拡張子がluaであるファイルを全てkpathseaが探せる場所においてください．
例えばTeX Liveの標準設定では\url{$TEXMF/scripts}以下に置くことができます．%$
また，
\begin{itemize}
\item UNIX: lbibtex.luaへのリンクを適当なbinディレクトリに作る．
\item Windows (TeX Live): bin/win32/runscript.exeをbin/win32/lbibtex.exeとしてコピーする．
\item W32TeX: bin/win32/runscr.exeをbin/win32/lbibtex.exeとしてコピーする．
\end{itemize}
とします．
または，代わりに\url{lbibtex}（UNIX）または\url{lbibtex.bat}（Windows）をPATHの通っている場所におくことでも実行が可能になります．

\begin{lstlisting}[language=bash]
$ bibtex sample
\end{lstlisting}
としていた代わりに
\begin{lstlisting}[language=bash]
$ lbibtex sample
\end{lstlisting}
とします．つまり，sample.texを処理するには
\begin{lstlisting}[language=bash]
$ latex sample.tex
$ lbibtex sample
$ latex sample.tex
$ latex sample.tex
\end{lstlisting}
とします．
文字コードは（現在のところ）UTF-8に限定されています．



\section{データベースについて}
通常の.bibを読むことができます．
典型的には次のようになっています．
\begin{verbatim}
@article{reference,
   author = "Last, First",
   title = {Some title},
}
\end{verbatim}
これはreferenceという名前のついたarticleに関する情報です．
著者名とタイトルが定義されています．
本マニュアルでは，
\begin{itemize}
\item 各々のデータを「エントリー」
\item articleを「エントリータイプ」
\item referenceを「エントリーキー」
\item 著者名などの情報を「フィールド」
\item author = "Last, First"におけるauthorを「キー」"Last, First"を「値」
\end{itemize}
と呼ぶことにします．
エントリータイプ，エントリーキー，またフィールドのキーは大文字小文字を無視して処理されます．

また次のようなデータ
\begin{verbatim}
@string{str = "some string"}
@article{reference
   title = "Title and " # str
}
\end{verbatim}
に対しては，文字列の連結と置換が行われます．
たとえばこの例ではreference内のtitleに対する値が\luastring{Title and some string}と置き換えられます．
このような置き換えのルール（今の場合はstrを\luastring{some string}に置き換える）をマクロと呼ぶことにします．
マクロはこのようにデータベース内のstringエントリーを使っても定義できますし，スタイルファイル内で定義することもできます．


正確には次のようなEBNFで定義されたファイルを読みます．
\begin{verbatim}
Database = (Ignored '@' Entry)*
Ignored = [^@]*
Entry = Preamble|Comment|String|Data
Comment = "comment" ('{' Name '}'| '(' Name ')')
Preamble = "preamble" ('{' Name '}'| '(' Name ')')
String = "string" ('{' Fields '}'|'(' Fields ')')
Data = Entry_Type ('{' Entry_Key ',' Fields '}'|'(' Entry_Key ',' Fields ')')
Entry_Type = [^{(]*
Entry_Key = Name
Fields = Field? (,Field)* ','?
Field = Key '=' Value
Key = Name
Value = Name
Name = ([^{}"]+ | '"'[^"]*'"' | '{' Name '}')*
\end{verbatim}

\begin{itemize}
\item Ignoredは無視されます．通常空白と改行のみを含みます．（ただし，この部分をコメントとして用いることも可能です．）
\item Commentはコメントです．無視されます．
\item Preambleはそのままbblに書き出されることが想定されています．
\item Stringはマクロを定義します．これは後述の「文字列連結機能」にて用いられます．
\item Dataが文献情報を表します．
\end{itemize}


また文字列の連結および置換は次のように振る舞います．
\begin{verbatim}
Value = EachString ('#' EachString)*
EachString = ([^#{}"]* | '"' [^"]* '"' | '{' EachString '}')*
\end{verbatim}
各々のEachStringには以下の処理が施されます．
\begin{itemize}
\item 前後の空白は全て無視されます．
\item EachStringと同じ文字列がマクロとして定義されていた場合，対応する文字列に変更されます．
\item 最後に，最初及び最後の\verb|"{}|は削除されます．
\end{itemize}


\section{スタイルファイルの書き方}
Lua言語によりスタイルを記述することができます．kpathseaから見える場所に\url{lbt-<style>_bst.lua}として保存してください．（\url{<style>}はスタイル名．）
標準のplain, alpha, abbrv, unsrtに対応するファイルは既に用意されています．

スタイルファイルの中身は，Luaスクリプトファイルです．
グローバル変数BibTeXを通じ，各種設定などを行います．
多くの場合，次のような流れになるでしょう．
\begin{enumerate}
\item \luavar{BibTeX.blockseparator}に，テンプレート設定で使うセパレータを設定する．
\item \luavar{BibTeX.templates}と\luavar{BibTeX.formatters}に実際にthebibliography環境として出力する内容のテンプレートを設定する．
\item \luavar{BibTeX.crossref}にクロスリファレンスの設定を行う．
\item \luavar{BibTeX.sorting}にソートの設定をする．
\item \luavar{BibTeX.label}にラベル出力の設定をする．
\item \luafunc{BibTeX:outputthebibliography()}で出力を行う．
\end{enumerate}
順番に見ていきます．


%ごくごく簡単なスタイルファイルは次のようになります
%\begin{lstlisting}
%-- article用のテンプレート定義
%BibTeX.blockseparator = {{", ","."}}
%BibTeX.templates["article"] = "[$<auhor>:$<title>:$<journal>:$<year>]"
%-- タイトルと著者の出力設定
%function BibTeX.formatter:author(c)
%	if c.fields["author"] == nil then return nil end
%	local a = LBibTeX.split_names(c.fields["author"])
%	if #a <= 2 then
%		return LBibTeX.make_name_list(a,"{ff~}{vv~}{ll}{, jj}",{", "," and "},", et~al.")
%	else
%		return LBibTeX.make_name_list(a,"{ff~}{vv~}{ll}{, jj}",{", ",", and "},", et~al.")
%	end
%end
%function BibTeX.formatter:title(c)
%	if c.fields["title"] == nil then return nil end
%	return LBibTeX.change_case(c.fields["title"],"t")
%end
%
%-- ソート設定
%default.sorting.targets = {"name","year","title"}
%
%-- CrossReference
%BibTeX.crossref.templates["article"] = "[$<author>:$<title>:\\cite{$<crossref>}]"
%
%-- ラベル
%BibTeX.label.make = nil
%
%-- 出力
%BibTeX:outputthebibliography()
%\end{lstlisting}
%%$
%
%たとえば次のように出力されるでしょう．
%\begin{lstlisting}[language={[latex]TeX}]
%\bibitem Noriyuki Abe, A title of something, journal, 2015.
%\end{lstlisting}
%
%このように，スタイルファイルは通常のLuaによるスクリプトです．

\subsection{テンプレート設定}\label{subsec:テンプレート設定}
\luavar{BibTeX.templates}，\luavar{BibTeX.formatters}および\luavar{BibTeX.blockseparator}を通じて設定を行います．
たとえば，エントリータイプarticleに対しては，著者，タイトル，ジャーナル，年をカンマ区切りで出し，最後にピリオドをつける場合は次のようにします．
\begin{lstlisting}
local Functions = require "lbt-funcs"

BibTeX.blockseparator = {{", ","."}}
BibTeX.templates["article"] = "[$<author>:<\\emph{|$<title>|}>:$<journal>:$<year>]"
function BibTeX.formatters:author(c)
	if c.fields["author"] == nil then return nil end
	local a = Functions.split_names(c.fields["author"])
	if #a <= 2 then
		return Functions.make_name_list(a,"{ff~}{vv~}{ll}{, jj}",{", "," and "},", et~al.")
	else
		return Functions.make_name_list(a,"{ff~}{vv~}{ll}{, jj}",{", ",", and "},", et~al.")
	end
end
\end{lstlisting}
\luavar{BibTeX.templates}に実際に出力される内容を設定します．
次のような書式で指定します．
\begin{itemize}
\item \luastring{[A:B:C...:X]}は「ブロック」を表します．各ブロックには「セパレータ」\luastring{<sep>}と「終端文字列」\luastring{<last>}が設定されており，\luastring{A<sep>B<sep>C...<sep>X<last>}というように出力されます．ただし，たとえば\luastring{B}が空文字列の場合は，\luastring{A<sep>C...<sep>X<last>}というように出力されます．
なお，このセパレータや終端文字列では，\luastring{.}が連続しないように処理がされます．ブロックはネストが可能です．
\item \luastring{$<A>}はフィールドAの出力を行います．Aがフィールドにない場合は空文字列になります．また\luastring{$<A|B|...|X>}と続けることもできて，この場合はA,B,...,Xの中で最初に定義されているものが出力されます．
\item \luastring{<A|B|C>}は，Bが空文字列ならば空文字列に，そうでないならば\luastring{ABC}という文字列になります．ネストが可能です．
\item 特殊文字は\luastring{%}でエスケープできます．
\end{itemize}

ブロックのセパレータと終端文字列は\luavar{BibTeX.blockseparator}で設定します．
中身は配列で，
\begin{lstlisting}
BibTeX.blockseparator = {
    {<ネストレベル1のセパレータ>,<ネストレベル1の終端文字列>},
    {<ネストレベル2のセパレータ>,<ネストレベル2の終端文字列>},
    ...
}
\end{lstlisting}
という形です．

\luastring{$<A|B|...|X>}で出力される各種フィールドの出力は\luavar{BibTeX.formatters}により整形されます．%$
その実体は関数で，キーnameのフィールドの整形を行う関数は
\begin{lstlisting}
function BibTeX.formatters:name(c)
-- 本体
end
\end{lstlisting}
という形で定義します．
戻り値は文字列です．
引数\luavar{c}には
\begin{itemize}
\item \luavar{c.key}にはエントリーキー
\item \luavar{c.type}にはエントリータイプ
\item \luavar{c.fields[name]}にはキーがnameのフィールドの中身
\end{itemize}
が入っています．
より詳しくは節\ref{sec:文献データ}を参照してください．
上のauthorの例ではモジュール\luavar{lbt-funcs}の提供する関数を使っています．
節\ref{sec:関数}を参照してください．

BibTeX.formattersの名前は実際のフィールド名である必要はありません．
たとえば
\begin{lstlisting}
BibTeX.templates["article"] = "$<author_editor>:$<title>"
function BibTeX.formatters:author_editor(c)
    if c.fields["author"] == nil then return c.fields["editor"]
    else return c.fields["author"]
end
\end{lstlisting}
とすると，\luastring{$<author_editor>}%$
は「authorが定義されていればauthorフィールドに，そうでなければeditorフィールド」という扱いになります．（つまり\luastring{$<author|editor>}と同等．）%$

少し発展的な内容です．
\begin{itemize}
\item ブロックの定義において，\luastring{[A:@S<sep>B:C]}とすると，Bの前のセパレータを\luastring{sep}に変更できます．
\item \luastring{$<A|(B)|C|...|X>}とすると，Bはフィールド名ではなく，テンプレートして解釈されます．たとえば，\luastring{$<author|(<edited by |\$<editor>|.)>}とすると，
\begin{itemize}
\item authorが定義されていればauthorフィールドそのまま．
\item authorが定義されていなく，editorが定義されていれば\luastring{edited by <editorフィールド>.}
\item authorもeditorも定義されていなければ空文字列
\end{itemize}
が出力されます．
\item formattersにもtemplatesのような書式が使えます．たとえば上の\luafunc{BibTeX.formatters:author\_editor}の例は
\begin{lstlisting}
BibTeX.formatters.author_editor = "$<author|editor>"
\end{lstlisting}
%$
と書くこともできます．
なお，ここでの\luastring{$<A>}%$
によるフィールド名の参照は，必ずフィールドの内容そのままとして解釈され，formattersによる整形は行われません．
\item formattersの関数の戻り値は原則文字列ですが，文字列の配列を返すこともできます．
これはブロックとして扱われます．
たとえば
\begin{lstlisting}
BibTeX.templates["article"] = "[$<author>:$<title_journal_year>]"
function BibTeX.formatters:title_journal_year(c)
    return {c.fields["title"],c.fields["journal"],c.fields["year"]}
end
\end{lstlisting}
と
\begin{lstlisting}
BibTeX.templates["article"] = "[$<author>:$<title>:$<journal>:$<year>]"
\end{lstlisting}
は等価です．
\end{itemize}

\subsection{クロスリファレンス}
クロスリファレンスの設定はBibTeX.corssrefに対して行います．
例としては次のようになります．
\begin{lstlisting}
BibTeX.crossref.templates["article"] = "[$<author>:$<title>:\\cite{$<crossref>}]"
\end{lstlisting}
%$
これにより，corssrefフィールドが定義されているarticleに対しては，その出力が上で指定されたものに変わります．
なお，\luavar{formatters}や\luavar{blockseparator}は\luavar{BibTeX.formatters}や\luavar{BibTeX.blockseparator}がそのまま使われます．
また，\luavar{BibTeX.crossref.templates["article"]}が定義されていない場合は\luavar{BibTeX.formatters["article"]}が使われます．

\subsubsection{クロスリファレンスの遺伝}
クロスリファレンスが行われると，親エントリーから子エントリーへとフィルードのコピーが行われます．
デフォルトでは，そのままのコピーが行われますが，この挙動は制御することができます．
たとえば
\begin{lstlisting}
BibTeX.crossref.inherit["article"]["book"] = {
    {"title","booktitle"},
    {{"author","editor"},"editor"},
    {{"A","B"},{"C","D"}}
}
\end{lstlisting}
とすると，親：article，子：bookというクロスリファレンスに対して
\begin{itemize}
\item titleはbooktitleにコピー
\item authorとeditorはeditorにコピー
\item A,BはC,Dの両方にコピー
\end{itemize}
が行われます．各々の項目に空文字列\luastring{}を指定すると，それは「全部」を表します．
たとえば
\begin{lstlisting}
BibTeX.crossref.inherit[""][""] = {
    {"title","booktitle"}
}
\end{lstlisting}
は全てのエントリータイプに対して，titleをbooktitleへとコピーします．
個別の指定は，\luastring{}による全てへの指定より優先されます．
たとえば
\begin{lstlisting}
BibTeX.crossref.inherit[""][""] = {
    {"title","booktitle"}
}
BibTeX.crossref.inherit["article"][""] = {
    {"title","subtitle"}
}
\end{lstlisting}
という指定は，articleからの場合に限りtitleをsubtitileに，それ以外はtitleをbooktitleにコピーします．

\subsubsection{その他の設定}
子エントリーに既にフィールドが存在している場合に上書きするかどうかは，\luavar{BibTeX.crossref.override}で制御します．
簡単な方法は
\begin{lstlisting}
BibTeX.crossref.override = true
\end{lstlisting}
とすることです．
これで全てのフィールドが上書きされます．（なお，デフォルトはfalseです．）
inheritと同様個別の定義を行うこともできます．
たとえば
\begin{lstlisting}
BibTeX.crossref.override["article"]["book"] = {
    {{"author","editor"},{"bookeditor"},true}
}
\end{lstlisting}
は親：articleのauthorかeditorフィールドが子：bookのbookeditorフィールドにコピーされる場合に上書きを許すことを意味します．
inheritと同様\luastring{}は全ての項目を表します．

その他以下の項目が設定できます．
\begin{itemize}
\item \luavar{BibTeX.crossref.mincrossrefs}：ここに設定されているだけのクロスリファレンスがあれば，エントリーが現在の参考文献一覧に追加されます．デフォルト2．
\item \luavar{BibTeX.crossref.reference\_key\_name}：クロスリファレンスを表すフィールドのキー名です．デフォルト\luastring{crossref}．
\end{itemize}

\subsection{ソート}
ソートに関する設定は，\luavar{BibTeX.sorting}で行います．
\begin{lstlisting}
BibTeX.sorting.targets = {"name","title","year"}
\end{lstlisting}
とすると，「名前」「タイトル」「年」の順番で比較されます．タイトルと年については，ほぼフィールド名そのまま\footnote{タイトルの頭文字のA, An, Theは取り除かれる．}で比較されます．名前については，デフォルトでは
\begin{itemize}
\item book, inbook: author/editor/key
\item proceedings: editor/organization/key
\item manual: author/organization/key
\item その他: author/key
\end{itemize}
のうち定義されている最初のものになります．
\luavar{BibTeX.sorting.targets}には上の\luastring{name}とフィールド名の他，\luastring{entry_key}（エントリーキー），\luastring{label}（ラベル）が指定できます．

実際に比較する値は，BibTeX.sorting.formattersで設定可能です．
\begin{lstlisting}
function BibTeX.sorting.formatters:name(c)
....
end
\end{lstlisting}
とすると，上のnameに対応する定義を上書きすることができます．

比較するための関数は，
\begin{itemize}
\item 一致しているか否かを返す\luafunc{BibTeX.sorting.equal}
\item $<$であるかを返す\luafunc{BibTeX.sorting.lessthan}
\end{itemize}
で設定できます．
デフォルトでは
\begin{lstlisting}
local function purify(s)
    return s:gsub("\\[a-zA-Z]*",""):gsub("[ -/:-@%[-`{-~]","")
end
function BibTeX.sorting.lessthan(a,b)
    return unicode.utf8.lower(purify(a)) < unicode.utf8.lower(purify(b))
end
function BibTeX.sorting.equal(a,b)
    return unicode.utf8.lower(purify(a)) == unicode.utf8.lower(purify(b))
end
\end{lstlisting}
と定義されています．

\subsection{ラベル}
thebibliography環境における
\begin{lstlisting}[language={[latex]TeX}]
\bibitem[label]{key} ....
\end{lstlisting}
のlabelの部分をラベルと呼ぶことにします．
デフォルトでは，著者などから自動的に生成されます．
ただし，shorthandフィールドがある場合には，その値が使われます．
ラベルの生成を押さえる（標準スタイルの「plain」に対応）には
\begin{lstlisting}
BibTeX.label.make = nil
\end{lstlisting}
とします．

より細かく設定する場合は，\luavar{BibTeX.label.templates}と\luavar{BibTeX.label.formatters}を設定します．
設定の方法はテンプレート（項\ref{subsec:テンプレート設定}）と同様です．
なお，同じラベル名が生成された場合，デフォルトでは末尾にa,b,c,...が追加されます．

\subsection{出力}
最後に
\begin{lstlisting}
BibTeX:outputthebibliography()
\end{lstlisting}
とすることで，\url{.bbl}ファイルが出力されます．

\section{関数}\label{sec:関数}
有用そうな関数群やオリジナルの\BibTeX に存在していた関数が，モジュール\luavar{lbt-funcs}で定義されています．
\begin{lstlisting}
local Functions = require "lbt-funcs"
x = Functions.text_prefix(str,num)
\end{lstlisting}
のように使ってください．

\subsection{\luafunc{stable\_sort(list,comp)}}
配列\luavar{list}に対して，安定なソートを行います．
\luavar{comp}は比較関数です．
省略された場合は標準演算子 \luafunc{<} が使われます．

\subsection{\luafunc{text\_prefix(str,num)}}
\luavar{str}の先頭\luavar{num}バイトを返します．
ただし，文字を途中で切ることはなく，またコントロールシークエンス等や引数はバイト数に加算されません．
たとえば，
\begin{lstlisting}
text_prefix("aあい",2)
text_prefix("あいう",5)
\end{lstlisting}
はそれぞれ\luastring{aあ}，\luastring{あい}を返します．\footnote{内部コードはUTF-8なので，\luastring{あ}や\luastring{い}は3byteです．この扱いはどうするか考え中……．}

\subsection{\luafunc{text\_length(str)}}
strのバイト数を返しますが，コントロールシークエンス等や引数は加算されません．

\subsection{\luafunc{string\_split(str,func)}}
検索関数\luavar{func}により\luavar{str}を分割して返します．
戻り値は二つの配列で，一つ目の配列には分割された文字列，二つ目の配列には分割文字列が入ります．
たとえば
\begin{lstlisting}
string_split("aXbYc",function(s) return s:find("[XY]") end)
\end{lstlisting}
は
\begin{lstlisting}
{"a","b","c"},{"X","Y"}
\end{lstlisting}
を返します．


\subsection{\luafunc{change\_case(str,format)}}
大文字小文字の変換を行います．ただし，中括弧の中は処理されません．
\luavar{format}は\luastring{t}，\luastring{u}，\luastring{l}のどれかで，
\begin{itemize}
\item \luastring{u}，\luastring{l}はそれぞれ大文字，小文字への変換を表す．
\item \luastring{t}は小文字への変換を行うが，一文字目及び\luastring{: *}で表される文字の次の文字は変換されない．
\end{itemize}


\subsection{\luafunc{split\_names(names[,seps])}}
複数名の名前からなる文字列から，各人の名前の入った配列を得ます．
人と人との区切りを配列\luavar{seps}で与えることができます．（配列中のいずれかにマッチした部分で区切られる．）
\luavar{seps}のデフォルトは\verb|{"[aA][nN][dD]"}|です．

\subsection{\luafunc{get\_name\_parts(names)}}
名前からfirst name，last name，von part，jr partの四つの部分を抽出します．
戻り値は
\begin{lstlisting}
{first = <first part>, last = <last part>, von = <von part>, jr = <jr part>}
\end{lstlisting}
で，各々の部分は
\begin{lstlisting}
{parts = <array of name>, seps = <separator of names>}
\end{lstlisting}
です．%\verb|<array of name>|は各部分の名前が配列で，\verb|<separator of names>|はnames内で使われていた区切り記号を表します．
例えばvon-von Last Last, First, jrに対しては，次のように返ります．
\begin{lstlisting}
{
	first = {parts = {"First"}, seps = {}},
	last = {parts = {"Last","Last"}, seps = {" "}},
	von = {parts = {"von", "von"}, seps = {"-"}},
	jr = {pars = {"jr"}, seps = {}}
}
\end{lstlisting}

この関数は，次のルールに基づき名前を分解します．
\begin{enumerate}
\item \luastring{[ ,~\t%-]+}に該当するパターン\footnote{Luaの意味でのパターン}で区切り，配列を生成する．
\item 1で区切られた際に用いられた区切り文字のうち，最初の一文字がカンマ「,」のものの数を数える．この数に基づき，次の三つのパターンのどれかと見なす．
\begin{enumerate}
\item カンマがない：First von Lastのパターン．頭から見てvonと見なされるパターンの前までがFirst，後ろから見てvonと見なされるパターンの後ろまでがLast．vonがない場合は1で区切られたうちの最後の一つのみがLast．（ただし，区切り文字が\verb|"-"|のものはまとめて考える．例えば\luastring{First Last Last}のLastは\luastring{Last}であるが，\luastring{First Last-Last}ならば\luastring{Last-Last}である．）
\item カンマが一つ：von Last, Firstのパターン．von LastからLastを抜き出す処理は(a)と同じ．
\item カンマが二つ：von Last, Jr, Firstのパターン．von LastからLastを抜き出す処理は(a)と同じ．
\end{enumerate}
\item 2における「vonと見なされるパターン」とは，（基本的には）\footnote{実際には中括弧内や，コントロールシークエンスで定義されたアクセントなども考慮に入れる．}最初に現れたアルファベットが小文字であるもののことである．
\end{enumerate}


\subsection{\luafunc{forat\_name\_by\_parts(nameparts,format)}}
\luavar{format}にて指定された書式に基づき，名前の整形を行います．
\luavar{nameparts}は\luafunc{get\_name\_parts}で得られる戻り値と同じかたちで与えます．
\luavar{format}で与える書式は次の形です．
\begin{quote}
\begin{verbatim}
<str1>{<before1><name1><after1>}<str2>{<before2><name2><after2>}...
\end{verbatim}
\end{quote}
\begin{itemize}
\item \verb|<str1>|はそのまま出力される．
\item \verb|<name1>|は\luastring{l}，\luastring{ll}，\luastring{f}，\luastring{ff}，\luastring{v}，\luastring{vv}，\luastring{j}，\luastring{jj}の何れか．Last name，First name，von part，jr partに対応し，二つ続いているものは名前全体を，そうでないものは短縮形を表す．
\item \verb|<before1>|はそのまま出力される．ただし\verb|<name1>|に対応する部分がない場合，出力されない．
\item \verb|<after1>|は\verb|{<sep1>}<after1_>|か\verb|<after1_>|（中括弧なし）の何れかである．\verb|<sep1>|は\verb|<name1>|の各部分をつなぐ文字として使われ，\verb|<after1_>|は次の部分とのつなぐ文字として使われる．\verb|<sep1>|が省略された場合や，\luastring{~}であった場合は，空白（\luastring{ }か\luastring{~}）が状況に応じて使われる．もし常に\luastring{~}を出力したい場合は，\luastring{~~}を指定する．
\item \verb|<str2>|等も同様．
\end{itemize}

\subsection{\luafunc{format\_name(name,format)}}
\BibTeX のformat.names\$と似た関数です．
中身は
\begin{lstlisting}
return forat_name_by_parts(get_name_parts(name),format)
\end{lstlisting}
です．

\subsection{\luafunc{make\_name\_list(namearray, format, separray[, etalstr])}}
複数人の名前の配列から文字列を作ります．
\luavar{separray}の長さを\luavar{k}，\luavar{namearray}の長さを\luavar{n}とすると，
\begin{quote}
\begin{verbatim}
namearray[1]separray[1]namaearray[2]separray[2] .... 
namearray[n - k + 1]separray[2] ...
namearray[n - 1]separray[k]namearray[n]
\end{verbatim}
\end{quote}
という文字列を生成します．（実際には改行無し．）
ただし，\luavar{namearray}の各項は\luavar{format}に従い整形され（書式は\luafunc{format\_name\_by\_parts}と同様），またもし\luavar{namearray[n]}が\luastring{others}の場合は，\luavar{namearray[n]}は\luavar{etalstr}に置き換えられます．
デフォルトでは\luavar{etalstr}は空文字列です．

\subsection{\luafunc{remove\_TeX\_cs(s)}}
\luavar{s}から\TeX のコントロールシークエンスを取り除いた文字列を得ます．

\section{文献データ}\label{sec:文献データ}
文献データは以下のようなテーブルに格納されています．
変数名を\luavar{Citation}とします．
\begin{description}[style=nextline]
\item[\luavar{Citation.type}]
エントリータイプ
\item[\luavar{Citation.key}]
エントリーキー
\item[\luavar{Citation.fields}]
フィールドが格納されているテーブル．マクロなどが施された結果が帰る．
\item[function \luafunc{Citation:clone()}]
自分の複製を作ります．
\item[function \luafunc{Citation:set\_field(key,cite,key1)}]
文献データ\luavar{cite}のキー\luastring{key1}のフィールドを\luastring{key}に設定します．
\item[function \luafunc{Citation:get\_raw\_field(key)}]
キー\luastring{key}のフィールドの生の値（マクロなど適用前）を返します．
\end{description}


\section{変数\luavar{BibTeX}}
変数\luavar{BibTeX}には，現在の\LBibTeX の状態が格納されています．
\subsection{各種状態}
\begin{description}[style=nextline]
\item[\luavar{BibTeX.style}]
スタイル名．
\item[\luavar{BibTeX.cites}]
引用されている文献一覧からなる配列．各々の中身は節\ref{sec:文献データ}の通り．
\item[\luavar{BibTeX.db}]
読み込まれたデータベースを表すテーブル．エントリーキー\luastring{key}には
\begin{lstlisting}
BibTeX.db["key"]
\end{lstlisting}
でアクセスできる．各々の中身は節\ref{sec:文献データ}の通り．
\item[\luavar{BibTeX.aux}]
\url{aux}ファイル名．
\item[\luavar{BibTeX.aux\_contents}]
\url{aux}ファイル名の中身．\url{aux}の各行の
\begin{verbatim}
\somecs{arg1}[arg2](arg3)
\end{verbatim}
という行から
\begin{lstlisting}
{somecs = {
	{arg = "arg1", open = "{", close = "}"},
	{arg = "arg2", open = "[", close = "]"},
	{arg = "arg3", open = "(", close = ")"}
}}
\end{lstlisting}
というテーブルが生成されて，ここに格納されている．
括弧は上記の\luastring{{}}, \luastring{[]}, \luastring{()}が認識され，対応がとれているものとして扱われる．
\end{description}

\subsection{関数}
\begin{description}[style=nextline]
\item[\luafunc{BibTeX:output(str)}]
\url{bbl}への出力を行う．
\item[\luafunc{BibTeX:outputline(str)}]
\url{bbl}への一行出力を行う．
\item[\luafunc{BibTeX:outputthebibliography()}]
項\ref{subsec:出力設定}に従い\url{bbl}へのthebibliography環境の出力を行う．
\item[\luafunc{BibTeX:warning(str)}]
文字列\luavar{str}を警告として出力する．出力は標準出力および\url{blg}に対して行われる．
\item[\luafunc{BibTeX:error(str,exit\_code)}]
文字列\luavar{str}をエラーとして出力し，終了コード\luavar{exit\_code}でプログラムを終了する．
出力は標準エラー出力および\url{blg}に対して行われる．
\item[\luafunc{BibTeX:log(str)}]
\url{blg}に\luavar{str}を出力する．
\item[\luafunc{BibTeX:message(str)}]
標準出力に\luavar{str}を出力する．

\end{description}

\subsection{出力設定}\label{subsec:出力設定}
\begin{description}[style=nextline]
\item[\luavar{BibTeX.templates}]
出力される\texcs{\bibitem}のフォーマットを指定する．
書式は項\ref{subsec:テンプレート設定}に基づく．
\item[\luavar{BibTeX.formatters}]
\luavar{BibTeX.templates}，\luavar{BibTeX.crossref.templates}で使われる整形用の関数．
書式は項\ref{subsec:テンプレート設定}に基づく．
\item[\luavar{BibTeX.blockseparator}]
\luavar{BibTeX.templates}，\luavar{BibTeX.crossref.templates}におけるブロックの区切り文字．
\item[\luavar{BibTeX.crossref}]
クロスリファレンスの遺伝を設定する．
\item[\luavar{BibTeX.crossref.templates}]
クロスリファレンスが定義されている場合に使われるフォーマット．
値が定義されていない場合，\luavar{BibTeX.templates}が使われる．
\item[\luavar{BibTeX.sorting.targets}]
ソートの際に使われるフィールドキーを並べた配列．（正確には，テーブル\luavar{BibTeX.sorting.formatters}のキーを指定する．つまり，\luastring{key}を指定すると，関数\luafunc{BibTeX.sorting.formatters:key}が呼び出された結果が使われる．）
\item[\luavar{BibTeX.sorting.lessthan}, \luavar{BibTeX.sorting.equal}]
ソートのための比較関数．
\item[\luavar{BibTeX.sorting.formatters}]
ソート時のフィールドの整形関数からなるテーブル．比較の際に\luavar{self}と文献情報（節\ref{sec:文献データ}）が渡されて実行される．
\item[\luafunc{BibTeX.sorting.label:make}]
\luavar{self}と文献情報（節\ref{sec:文献データ}）を受け取り，ラベル名を返す関数を設定する．
ラベルを作らない場合はnilを設定する．
\item[\luafunc{self.label:add\_suffix}]
同一のラベル名があった場合に，ラベル名を変更する処理をおこなう関数を設定する．デフォルトでは末尾にa,b,c,...を付加する．
文献情報からなる配列（ソート済み）を受け，やはり配列を返す．
\item[\luafunc{self.label:modify\_citations}]
出力直前に実行される関数．最後の段階で文献情報を調整することができる．
文献情報からなる配列（ソート済み）を受け，やはり配列を返す．
\end{description}

%\subsection{\luafunc{LBibTeX.citation\_check(citations,required)}}
%\luavar{citations}に与えられた文献情報一覧を，\luavar{required}に従いチェックします．
%例えば
%\begin{lstlisting}
%required["article" ] = {required = {"author", "title"}, optional = {"volume", "number"}}
%\end{lstlisting}
%であった場合，articleにおいては，author，titleフィールドは必須であり，volume，numberフィールドは任意であることを意味します．（任意フィールドは今のところ無視されています．）
%また
%\begin{lstlisting}
%required["book" ] = {required = {{"author","editor"}, "title"}}
%\end{lstlisting}
%のようになっていた場合，bookにおいてはauthor，editorの何れかとtitleが必須であることを意味します．
%
%\luavar{citations}には文献情報からなるテーブルを与えます．
%戻り値は，例えば次のような形をしています．
%\begin{lstlisting}
%{key1 = {{"author","editor"}, "title"}, key2 = {"year"}}
%\end{lstlisting}
%key1には「authorまたはeditor」とtitleが，key2にはyearが欠落していることを示します．
%
%\subsection{\luafunc{LBibTeX.LBibTeX:output\_citation_check(citation_check)}}
%（これはLBibTeX以下に直接定義されているわけではなく，LBibTeX.LBibTeX以下であることに注意してください．）
%\luafunc{LBibTeX.citation\_check}での出力を受けて警告を表示します．


%
%
%\section{リファレンス}
%全ては\verb|LBibTeX|以下に定義されています．
%\begin{itemize}
%\item テーブルCLASSにCLASS.newという関数がある場合，最後に\verb|setmetatable(obj,{__index = CLASS})|して返されます．
%\item テーブルAがテーブルBを継承しているとは，\verb|setmetatable(CLASSA,{__index = CLASSB})|がされていることです．
%\end{itemize}
%
%\subsection{lbt-database}\label{subsec:lbt-database}
%データベースを読み込みます．
%各フィールドにはマクロが適用されます．
%ここでマクロの適用とは，@stringで定義された文字列の置換と，\verb|#|による文字列の結合を表します．
%\subsubsection{function LBibTeX.Citation.new()}
%文献情報を格納するためのテーブルを生成します．
%戻り値をcとすると，以下の意味を持ちます．
%直接呼び出されることはあまりないと思います．
%\begin{itemize}
%\item c.key ：エントリーキー
%\item c.type ： エントリータイプ
%\item c.fields ： フィールド．\verb|c.fields["author"]|のようにフィールドキーからその値を得られる．\verb|c.fields[U"author"]|でも得られる．もしデータベースに該当フィールドが存在しない場合はnilとなる．
%\item c.label ： \verb|\bibitem|に渡されるオプション．デフォルトはnilであり，この場合オプションは出力されない．
%\item c.bib ： もともとこの文献情報が格納されていたデータベースファイルを表す．
%\end{itemize}
%
%\subsubsection{function LBibTeX.Database.new()}
%文献読み込みのためのテーブルを生成します．
%\begin{itemize}
%\item db：データベース一覧です．エントリーキーがkeyのデータがdb[key]に入っています．db[key]の値はLBibTeX.Ciation.newで生成されたものです．db[key].fieldsから得られるフィールドは，データベース生の値ではなくてそれにマクロが施された形になっています．dbに追加をする場合は，次のadd\_dbを使ってください．
%\item preamble：データベース内で定義されたプレアンブル（を全て結合したもの）です．
%\item macros：マクロ一覧を表します．データベースから読み込まれたものはここには入りません．\verb|macros["jan"] = "January"|とするとjanがJanuaryになります．
%\item converter：フィールドを取得すると通常はマクロが適用されたものが出てきますが，たとえば\verb|converter["title"] = function(db,data) return "[" .. data.fields["title"] .. "]" end|と定義しておくと，titleに関しては生のtitleフィールドを[]で囲ったものになります．
%\end{itemize}
%
%\subsubsection{function LBibTeX.Database:read(file)}
%fileからデータベースを読み込みます．
%
%\subsubsection{function LBibTeX.Database:add\_db(cite)}
%citeはLBibTeX.Citations.new()で生成したテーブルを渡します．データベースに新しいデータを追加します．
%
%\subsubsection{function LBibTeX.Database:apply\_macro(data,key)}
%data.fields[key]にマクロを施した結果を得ます．
%
%\subsection{lbt-core}\label{subsec:lbt-core}
%\LBibTeX のコアとなる部分が定義されています．
%テーブルLBibTeX.LBibTeXはLBibTeX.Databaseを継承しています．
%
%\subsubsection{function LBibTeX.LBibTeX.new()}
%\LBibTeX の状態そのものを表すテーブルを生成します．
%
%\subsubsection{function LBibTeX.LBibTeX:load\_aux(file)}
%.auxファイルを読み取り，その情報を格納したテーブルを返します．データベースの読み込みも行います．
%\begin{itemize}
%\item aux ： auxファイル名
%\item style ： スタイル名
%\item cites ： 引用されている文献一覧
%\item bibs ： データベース名一覧
%\item aux\_contents ： .aux内に現れるコントロールシークエンスの一覧．
%たとえば
%\begin{verbatim}
%\relax
%\citation{cite1}
%\citation{cite2}
%\somecs{arg1-1}[arg1-2]{arg1-3}
%\somecs(arg2-1)(arg2-2)[arg2-3}
%\end{verbatim}
%という.auxファイルに対しては次のテーブルが生成されます．
%\begin{lstlisting}
%{
%	"citation" = 
%	{
%		{
%			{arg = "cite1",open = "{",close = "}"}
%		}
%	},
%	{
%		{
%			{arg = "cite2",open = "{",close = "}"}
%		}
%	}
%	
%	"somecs" = 
%	{
%		{
%			{arg = "arg1-1",open = "{",close = "}"},
%			{arg = "arg1-2",open = "[",close = "]"},
%			{arg = "arg1-3",open = "{",close = "}"},
%		},
%		{
%			{arg = "arg2-1",open = "(",close = ")"},
%			{arg = "arg2-2",open = "(",close = ")"},
%			{arg = "arg2-3",open = "{",close = "}"},
%		}
%	}
%}
%\end{lstlisting}
%\end{itemize}
%
%\subsubsection{function LBibTeX.LBibTeX:output(s)}
%文字列sを.bblへ出力します．
%
%\subsubsection{function LBibTeX.LBibTeX:outputline(s)}
%.bblへの一行出力を行います．
%
%\subsubsection{function LBibTeX.LBibTeX:outputcites(formatter)}
%.bblに\verb|\bibitem|を出力します．
%formatterはタイプをインデックス，関数を値とするテーブルです．
%例えば
%\begin{lstlisting}
%formatter["article"] = function(c)
%	return c.fields["author"]
%end
%\end{lstlisting}
%と定義されていると，articleに対しては著者のみが出力されます．
%
%\subsubsection{function LBibTeX.LBibTeX:outputthebibliography(formatter)}
%大体
%\begin{lstlisting}
%outputline("\\begin{thebibliography}{" .. get_longest_label() .. "}")
%outputcites(formatter)
%outputline("\\end{thebibliography}")
%\end{lstlisting}
%と等価です．
%
%\subsubsection{function LBibTeX.LBibTeX:get\_longest\_label()}
%もっとも長いラベルを返します．ラベルが設定されていない場合は空文字列が帰ります．
%
%\subsubsection{function LBibTeX.LBibTeX:warning(s)}
%警告を出力します．
%
%\subsubsection{function LBibTeX.LBibTeX:error(s,exit\_code)}
%エラーをユーザに通知し，\LBibTeX をエラーコードexit\_code で終了します．
%
%\subsubsection{function LBibTeX.LBibTeX:dispose()}
%LBibTeX.LBibTeXを破棄します．
%
%\subsection{lbt-ustring}
%ICU4Luaの提供するデータ型を返します．lbt-ustring.ustring = icu.ustring，lbt-ustring.ufile = icu.ufile，lbt-ustring.collator = icu.collatorという関係です．
%LBibTeX.use\_icu = falseの状態で呼び出された場合，ICU4Luaは呼び出されず，代わりにLua組み込み文字列によるエミュレートが行われます．
%この場合は（組み込み文字列と同様）単なるバイト列として扱われます．
%
%\subsection{lbt-funcs}
%様々な関数が定義されています．
%\subsubsection{function LBibTeX.text\_prefix(str,num)}
%strの先頭num文字を取り出します．
%ただし，\verb|{}|で囲まれた部分は一文字として計算されます．
%\BibTeX のtext.prefix\$ に似ています．
%
%\subsubsection{function LBibTeX.change\_case(str,format)}
%大文字小文字の変換を行います．ただし，中括弧の中は処理されません．formatは\verb|"t"|，\verb|"u"|，\verb|"l"|のどれかで，
%\begin{itemize}
%\item \verb|"u"|，\verb|"l"|はそれぞれ大文字，小文字への変換を表す．
%\item \verb|"t"|は小文字への変換を行うが，一文字目及び\verb|": *"|で表される文字の次の文字は変換されません．
%\end{itemize}
%\BibTeX のchange.case\$に似ています．
%
%\subsubsection{function LBibTeX.split\_names(names[,seps])}
%複数名の名前からなる文字列から，各人の名前の入った配列を得ます．
%人と人との区切りを配列sepsで与えることができます．（配列中のいずれかにマッチした部分で区切られる．）
%sepsのデフォルトは\verb|{"[aA][nN][dD]"}|です．
%
%\subsubsection{function LBibTeX.get\_name\_parts(names)}
%名前からfirst name，last name，von part，jr partの四つの部分を抽出します．
%戻り値は
%\begin{lstlisting}
%{first = <first part>, last = <last part>, von = <von part>, jr = <jr part>}
%\end{lstlisting}
%で，各々の部分は
%\begin{lstlisting}
%{parts = <array of name>, seps = <separator of names>}
%\end{lstlisting}
%です．%\verb|<array of name>|は各部分の名前が配列で，\verb|<separator of names>|はnames内で使われていた区切り記号を表します．
%例えばvon-von Last Last, First, jrに対しては，次のように返ります．
%\begin{lstlisting}
%{
%	first = {parts = {"First"}, seps = {}},
%	last = {parts = {"Last","Last"}, seps = {" "}},
%	von = {parts = {"von", "von"}, seps = {"-"}},
%	jr = {pars = {"jr"}, seps = {}}
%}
%\end{lstlisting}
%
%この関数は，次のルールに基づき名前を分解します．
%\begin{enumerate}
%\item \verb|[ ,~\t%-]+|に該当するパターンで区切り，配列を生成する．
%\item 1で区切られた際に用いられた区切り文字のうち，最初の一文字がカンマ「,」のものの数を数える．この数に基づき，次の三つのパターンのどれかと見なす．
%\begin{enumerate}
%\item カンマがない：First von Lastのパターン．頭から見てvonと見なされるパターンの前までがFirst，後ろから見てvonと見なされるパターンの後ろまでがLast．vonがない場合は1で区切られたうちの最後の一つのみがLast．（ただし，区切り文字が\verb|"-"|のものはまとめて考える．例えば``First Last Last''のLastは``Last''であるが，``First Last-Last''ならば``Last-Last''である．）
%\item カンマが一つ：von Last, Firstのパターン．von LastからLastを抜き出す処理は(a)と同じ．
%\item カンマが二つ：von Last, Jr, Firstのパターン．von LastからLastを抜き出す処理は(a)と同じ．
%\end{enumerate}
%\item 2における「vonと見なされるパターン」とは，（基本的には）\footnote{実際には中括弧内や，コントロールシークエンスで定義されたアクセントなども考慮に入れる．}最初に現れたアルファベットが小文字であるもののことである．
%\end{enumerate}
%
%
%\subsubsection{function LBibTeX.forat\_name\_by\_parts(nameparts,format)}
%formatにて指定された書式に基づき，名前の整形を行います．
%namepartsはLBibTeX.get\_name\_parts で得られる戻り値と同じかたちで与えます．
%formatで与える書式は次の形です．
%\begin{quote}
%\begin{verbatim}
%<str1>{<before1><name1><after1>}<str2>{<before2><name2><after2>}...
%\end{verbatim}
%\end{quote}
%\begin{itemize}
%\item \verb|<str1>|はそのまま出力される．
%\item \verb|<name1>|はl，ll，f，ff，v，vv，j，jjの何れか．Last name，First name，von part，jr partに対応し，二つ続いているものは名前全体を，そうでないものは短縮形を表す．
%\item \verb|<before1>|はそのまま出力される．ただし\verb|<name1>|に対応する部分がない場合，出力されない．
%\item \verb|<after1>|は\verb|{<sep1>}<after1_>|か\verb|<after1_>|（中括弧なし）の何れかである．\verb|<sep1>|は\verb|<name1>|の各部分をつなぐ文字として使われ，\verb|<after1_>|は次の部分とのつなぐ文字として使われる．\verb|<sep1>|が省略された場合や，\verb|"~"|であった場合は，空白（\verb|" "|か\verb|"~"|）が状況に応じて使われる．もし常に\verb|"~"|を出力したい場合は，\verb|"~~"|を指定する．
%\item \verb|<str2>|等も同様．
%\end{itemize}
%
%\subsubsection{function LBibTeX.format\_name(name,format)}
%\BibTeX のformat.names\$と似た関数です．
%中身は
%\begin{lstlisting}
%return LBibTeX.forat_name_by_parts(LBibTeX.get_name_parts(name),format)
%\end{lstlisting}
%です．
%
%\subsubsection{function LBibTeX.make\_name\_list(namearray, format, separray[, etalstr])}
%複数人の名前の配列から文字列を作ります．
%separrayの長さをk，namearrayの長さをnとすると，
%\begin{quote}
%\begin{verbatim}
%namearray[1]separray[1]namaearray[2]separray[2] .... 
%namearray[n - k + 1]separray[2] ...
%namearray[n - 1]separray[k]namearray[n]
%\end{verbatim}
%\end{quote}
%という文字列を生成します．（実際には改行無し．）
%ただし，namearrayの各項はformatに従い整形され（書式はLBibTeX.format\_name\_by\_partsと同様），またもしnamearray[n]が``others''の場合は，namearray[n]はetalstrに置き換えられます．
%デフォルトではetalstrは空文字列です．
%
%\subsubsection{function LBibTeX.remove\_TeX\_cs(s)}
%sから\TeX のコントロールシークエンスを取り除いた文字列を得ます．
%
%\subsubsection{function LBibTeX.citation\_check(citations,required)}
%citationsに与えられた文献情報一覧を，requiredに従いチェックします．
%例えば
%\begin{lstlisting}
%required["article" ] = {required = {"author", "title"}, optional = {"volume", "number"}}
%\end{lstlisting}
%であった場合，articleにおいては，author，titleフィールドは必須であり，volume，numberフィールドは任意であることを意味します．（任意フィールドは今のところ無視されています．）
%また
%\begin{lstlisting}
%required["book" ] = {required = {{"author","editor"}, "title"}}
%\end{lstlisting}
%のようになっていた場合，bookにおいてはauthor，editorの何れかとtitleが必須であることを意味します．
%
%citationsには文献情報からなるテーブルを与えます．
%戻り値は，例えば次のような形をしています．
%\begin{lstlisting}
%{key1 = {{"author","editor"}, "title"}, key2 = {"year"}}
%\end{lstlisting}
%key1には「authorまたはeditor」とtitleが，key2にはyearが欠落していることを示します．
%
%\subsubsection{function LBibTeX.LBibTeX:output\_citation\_check(citation\_check)}
%（これはLBibTeX以下に直接定義されているわけではなく，LBibTeX.LBibTeX以下であることに注意してください．）
%LBibTeX.citation\_check(citations,required)での出力を受けて警告を表示します．
%
%\subsection{lbt-crossref}
%Cross Referenceを処理します．
%
%\subsubsection{function LBibTeX.CrossReference.new()}
%Cross Referenceを処理するための新しいテーブルを作成します．
%\begin{itemize}
%\item LBibTeX.CrossReference.reference\_key\_name ： Cross Referenceを表すフィールドキーです．デフォルトはcrossref．
%\item LBibTeX.CrossReference.mincrossrefs ： この値以上にCross Referenceがされていたら文献一覧に加えます．デフォルトは1．
%\item LBibTeX.CrossReference.override ： 既にフィールドが値を持っていた場合，Cross Referenceのフィールドで上書きをするかを指定します．デフォルトはfalse．
%\end{itemize}
%
%\subsubsection{function LBibTeX.CrossReference:add\_inherit(source\_type,target\_type,source\_key,target\_key)}
%Cross Referenceされている場合に，その親から子に受け継がせるフィールドキーの対応を指定します．例えば
%\begin{verbatim}
%@article{"child",
%    author = "child author",
%    title = "child title",
%    crossref = "parent"
%}
%@book{"parent",
%    editor = "parent editor",
%    title = "parent title"
%}
%\end{verbatim}
%とある場合，通常parentのtitleはchildのtitleに割り当てあられますが，
%\begin{lstlisting}
%add_inherit("article","book","title","subtitle")
%\end{lstlisting}
%とあれば，parentのtitleはchildのsubtitleに割り当てられます．
%
%複数の設定を同時に行うこともできます．
%\begin{lstlisting}
%add_inherit({"article","inbook"},{"book","proceedings"},{"title","booktitle"},"subtitle")
%\end{lstlisting}
%は，タイプがarticleまたはinbookの親がタイプがbookかproceedingsの子にCross Referenceされている場合，titleとbooktitleフィールドをsubtitleに割り当てます．
%更に，
%\begin{lstlisting}
%add_inherit(
%	LBibTeX.CrossReference.all_type,
%	LBibTeX.CrossReference.all_type,
%	LBibTeX.CrossReference.all_type,
%	"subtitle")
%\end{lstlisting}
%とすると，全てのタイプからCross Referenceされている全てのタイプに対して，その全てのフィールドをsubtitleに割り当てることを意味します．
%なお，デフォルトでは同名のフィールドに割り当てます．
%
%\subsubsection{function LBibTeX.CrossReference:add\_except(source\_type,target\_type,source\_key,target\_key)}
%add\_inherit での指定に対する例外を指定します．指定方法はadd\_inherit と同様です．
%
%\subsubsection{function LBibTeX.CrossReference:modify\_citations(cites,db)}
%add\_inherit 等の指定に従い，文献一覧情報を変更し，変更した結果のcitesを返します．
%citesはLBibTeX.Citation.newで生成したテーブルの配列，dbにはLBibTeX.Database.newで生成したテーブルを渡します．
%
%\subsubsection{function LBibTeX.CrossReference:make\_formatter(orig\_formatter,crossref\_formatter)}
%Cross Reference用のフィールドが定義されていればcrossref\_formatter[type]を，そうでなければorig\_formatter[type]を呼び出す関数からなるテーブルを作成します．
%typeは文献のタイプです．
%なお，crossref\_formatter[type]がnilの時は常にorig\_formatter[type]を呼び出します．
%
%\subsection{lbt-template}
%文献一覧の整形を行う関数の生成を補助します．
%
%\subsubsection{function LBibTeX.Template.new()}
%新たなテーブルを作ります．
%
%
%\subsubsection{function LBibTeX.Template:make(templs,funcs)}
%\begin{lstlisting}
%templs["article"] = "[$<author|editor>:<\\emph{|$<title>|}>]"
%\end{lstlisting}
%のようなtemplsから，文献一覧の整形を行う関数を生成します．（LBibTeX.LBibTeX:outputcitesに直接渡せるもの．）
%この文字列は次のような意味を持ちます．
%\begin{itemize}
%\item \verb|[A:B:...:X]|：「ブロック」を表します．最終的にはこれは\verb|A<sep>B<sep>....<sep>X<last>|となります．ただし，空文字列の時は省略されます．（\verb|[A:B:C]|でBが空ならば\verb|A<sep>C<last>|となる．）ブロックはネストが可能です．\verb|<sep>|や\verb|<last>|はそれぞれself.blockseparator[nestlevel]及びself.blocklast[nestlevel]で指定します．
%\verb|<sep>|は一時的に変更することも可能です．\verb|[A:B:@S<special sep>C:D]|は，\verb|A<sep>B<special sep>C<sep>D<last>|となります．ただし，Cが空文字列の場合は\verb|A<sep>B<sep>D<last>|となります．また，\verb|<sep>|や\verb|<last>|の処理によりピリオドが続いた場合，ピリオドを削除します．例えば\verb|[string A.]|で\verb|<last>|が\verb|"."|であった場合は，「string A..」ではなく，「string A.」となります．
%\item \verb:<A|B|C>:は，Bが空文字列ならば空文字列に，そうでなければABCになります．
%\item \verb:$<A|B|...>:
%は，まずfuncs.Aを呼び出し，その結果が空文字列ならばfuncs.Bを呼び出し……と続け，最初に空文字列でないものであった場合にその値になります．もしfuncs.Aがnilならば，これはAというフィールドを返す関数であると見なされます．
%\end{itemize}
%funcsは次のような関数からなるテーブルです．
%\begin{lstlisting}
%function funcs.title(c)
%	if c.fields["title"] == nil then return nil end
%	return LBibTeX.change_case(c.fields["title"],"t")
%end
%\end{lstlisting}
%引数cはLBibTeX.Citation.new()により得られたテーブルです．
%このようにnilまたは文字列を返すのが基本ですが，配列を返すこともできます．
%これはブロックを区切り付きで返していることに対応します．例えばtemplが
%\begin{lstlisting}
%"[$<name>]"
%\end{lstlisting}
%であり，
%\begin{lstlisting}
%function funcs.name(c)
%	return {c.fields["author"],c.fields["editor"]}
%end
%\end{lstlisting}
%と定義されている場合は，templが
%\begin{lstlisting}
%"[$<author>:$<editor>]"
%\end{lstlisting}
%と定義されているのと等価になります．
%
%\subsection{lbt-styles-**}
%**は現在stdとamsがあります．
%lbt-style-stdには，plain，alpha，abbrv，unsrtスタイルが共有する部分が定義されています．
%このように特殊なスタイルに対する定義ではありますが，一般のスタイルファイルを作成する際にも有用な処理がいくつかあります．
%実際，lbt-styles-amsは内部でlbt-style-stdを呼んでいます．
%以下lbt-style-stdの解説をしますが，lbt-styles-amsでも同様です．
%requireによる戻り値をlbt-style-stdとします．
%\subsubsection{lbt-style-std.macros}
%マクロが定義されたテーブルです．
%
%\subsubsection{function lbt-style-std.make\_label(c)}
%[Abe15]のようなラベルを生成します．
%基本的にはauthorフィールドまたはeditorフィールド（タイプがproceedingsの時）から，著者名の頭3文字（単著の場合）または著者名のvon Last（省略形）をつなげ，年の最後二文字をつけたものを生成します．ただし，
%\begin{itemize}
%\item book，inbookでauthorがない場合は代わりにeditorフィールドを使います．
%\item authorやeditorがない場合は，keyフィールドを使います．
%\item proceedingsやmanualの場合，更にkeyがなければorganizationフィールドを使います．
%\end{itemize}
%
%\subsubsection{function lbt-style-std.sort(cites[,array[,formatter[,equals[,lessthan]]]])}
%citesにソートを行い，結果を返します．
%なお，この関数はcites[index].sort\_keyを汚します．
%\begin{itemize}
%\item array ： 比較する対象を配列で指定します．デフォルトは\verb|{"label","name","year","title","entry_key"}|です．これはまずformatter.labelの結果を比較し，それが同じならばformatter.nameの結果を比較し……とすることを意味します．
%\item formatter ： 比較する文字列を生成します．デフォルトは
%\begin{itemize}
%\item formatter.name(c)は，名前を\verb|{vv{ } }{ll{ }}{  ff{ }}{  jj{ }}|に基づいて整形したものを並べたのものを返す．ただし名前とはauthorまたはeditor（proceedingsの場合）であり，またbook，inbookにおいてauthorが定義されていないならばeditorを選ぶ．またproceedingsやmanualの場合にauthorやeditorが定義されていないならばorganizationを使う．
%\item formatter.title(c)は，頭の「The 」「A 」「An 」を取り除いたものを返す．
%\item formatter.label(c)は，c.labelを返す．
%\item formatter.entry\_key(c)は，c.keyを返す．
%\end{itemize}
%なお，formatterが定義されていない場合（デフォルトでは例えばformatter.year）は，その名前のフィールドを返すものと見なされます．
%またformatterが定義されている場合は，sort\_key 以下にformatterを施した結果を保持します．（高速化のため．）
%\item equals ： 文字列が等しいかを判定する関数．デフォルトはicu.collator.equals（localeはUS）．
%\item lessthan ： 文字列が小さいかを判定する関数．デフォルトはicu.collator.lessthan（localeはUS）．
%\end{itemize}
%
%\subsubsection{lbt-style-std.blockseparator}
%LBibTeX.Template.blockseparatorに設定するための配列です．
%
%\subsubsection{lbt-style-std.blocklast}
%LBibTeX.Template.blocklastに設定するための配列です．
%
%\subsubsection{lbt-style-std.Templates}
%LBibTeX.Template.makeの第一引数に渡すためのテーブルです．
%
%\subsubsection{lbt-style-std.Formatter}
%LBibTeX.Template.makeの第二引数に渡すためのテーブルです．
%
%\subsubsection{lbt-style-std.CrossReference}
%Cross Referenceを処理するためのテーブルです．
%LBibTeX.CrossReference.new()で生成されています．
%
%\subsubsection{lbt-style-std.CrossReference.Templates}
%LBibTeX.Template.makeの第一引数に渡すためのテーブルです．
%その結果はlbt-style-std.CrossReference:modify\_citationsの第二引数に使います．

\end{document}


